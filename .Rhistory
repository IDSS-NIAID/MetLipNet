colnames(Data_Corr)<-as.factor(Data_Raw[1:255,1])#pulls the feature names back to the columns of the numeric matrix.
Data_Corr_Result<-rcorr(as.matrix(Data_Corr),type = c("pearson"))#cor_mat() function should do the same thing from the rstatix package but I haven't tested it yet as an input to the igraph packages.
R_Data_Corr<-Data_Corr_Result[["r"]]
p_Data_Corr<-Data_Corr_Result[["P"]]
#write.csv(R_Data_Corr, file="Notarangelo0001 R vals pearson all v all.csv")#Option to write the R matrix to a csv. You can do the same thing for the p values for handling elsewhere if needed.
#write.csv(p_Data_Corr, file="Notarangelo0001 p vals pearson all v all.csv")
#NETWORK ANALYSIS WITH IGRAPH
R_ABS<-abs(R_Data_Corr)#convert to absolute values so that you can look at a network of high corr and anticorr
R_Sig<-R_ABS
R_Sig[R_Sig<0.6]<-0#replace anything below an R cut-off with a 0. Play with this to manage how many features make it through to the eventual network.
R_Net <- graph_from_adjacency_matrix(R_Sig, weighted=T, mode="undirected", diag=F)#This creates the network object which can be modified from here
R_Net_DF<-igraph::as_data_frame(R_Net, 'both')#split the igraph NET object into seperate edge and node(vertex) dataframes so that you can add attributes
Class_DF<-Data_Raw[1:255,1:3]#Create a Class ID dataframe. In the sample dataframe I used two attributes in columns 2 and 3 so this creates a seperate dataframe with those values.
R_Net_DF$vertices <- R_Net_DF$vertices %>%
left_join(Class_DF, by=c('name'='Metabolite'))#stitch the class ids into the vertices dataframe
#Optional. This is an attempt to add in the -Log(p) of the correlations as a edge attribute. It can be buggy and you can skip it.
Data_Corr_Flat<-cor_gather(Data_Corr_Result)#flattens the r and p results into a 4 column format that can be linked to the edge DF dataframe as attributes. Note that the data is technically duplicated with each correlation being recognized in each direction so you can't screw up the call direction below.
Data_Corr_Flat$neg_Log_p<-log10(Data_Corr_Flat$p)*-1#Adds in the -Log(p) column for assignment ot the edge weight below. This is for if you want to map the p-values from the correlations onto the map is some way. You can skip this for a simpler plot.
R_Net_DF$edges <- R_Net_DF$edges %>%
left_join(Data_Corr_Flat, by=c('from'='var1','to'='var2'))#stitch the correlation stats into the edges as attirbutes
#Rebuild the network object from the two dataframes (vertices and edges with their respective attributes)
R_Net <- graph_from_data_frame(R_Net_DF$edges,
directed = F,
vertices = R_Net_DF$vertices)#Recreate the network object from the Vertices and edges dataframes
#This is an attempt to remove edges that don't pass a certain p-value cut-off. Let me know if it doesn't work.
insig_edge<-which(edge_attr(R_Net,"neg_Log_p")<1)#this is currently set with 0.01 as the cut-off but you can toggle accordingly
R_Net_trim<- delete.edges(R_Net, insig_edge)
#These are two options that can be used to remove vertices based on degree (i.e. connectivity of a vertice). This is a great way to trim off non-informative patterns from the network. You can iterate these functions as necessary.
low_con_verts<- which(degree(R_Net_trim)<3)#identify any nodes with edges below a cut-off
R_Net_trim<- delete.vertices(R_Net_trim, low_con_verts)#remove low degree vertices. This will likely leave some loner vertices out there that get cut out in the next step.
Iso_verts<- which(degree(R_Net_trim)==0)#identify any vertices with no edges in the network
R_Net_trim<- delete.vertices(R_Net_trim, Iso_verts)#remove unconnected vertices
#Color the edges by the sign of R and assign them as edge attribute.
E(R_Net_trim)$color <- ifelse(E(R_Net_trim)$cor < 0,"purple",  "orange") # pick colors, purple = neg, orangehttp://127.0.0.1:15877/graphics/plot_zoom_png?width=2048&height=1104 = positive
#color by attribute of the vertices that was inserted into the original input file
Color_pal<-colorRampPalette((brewer.pal(3,"RdYlBu")))#expands the color palette through extrapolation for node coloring.Pick your favorite palette and dictate how many colors in that palette get blended by the number.
par(mar = rep(.1,4)) # this sets the margins to something very small so you make better use of the plotting area
#FINAL PLOT. To plot with no vertex labels just insert "vertex.label=NA" and remove the rest of the vertex.label specs
Layout.pref<-layout_with_fr(R_Net_trim)
plot(R_Net_trim,
layout=Layout.pref,
vertex.size=3,
vertex.frame.color=NA,
vertex.shape=Class_DF$Shape,
vertex.label.family="sans",
vertex.label.color="black",
vertex.label.cex=1.5,
vertex.color =  Color_pal(length(unique(Class_DF$Class)))[as.numeric(as.factor(vertex_attr(R_Net_trim, "Class")))],
edge.width=1,
edge.color=E(R_Net_trim)$color)
#CORRELATION MATRIX GENERATION. This will make an "All vs. All" matrix of correlations for your input dataset.
Data_Raw<-read.csv("Gwen_GiGi_CleanedData.csv")#Dataset should be a simple matrix with rows as features and columns as experimental conditions and/or repeats. Feature attributes (i.e. GO annots or chromosome regions) can be included as columns.You can also include columns that manully specify graph characteristics such as shape for a subset of features.
Data_Clean<-Data_Raw[1:255,4:25]#remove anything that is not a metabolite abundance//count
Data_Num<-mutate_all(Data_Clean, function(x) as.numeric(as.character(x)))#Convert all entries to numerics. Sometimes this isn't necessary but its a good check
Data_Corr<-t(Data_Num)#input to the rcorr() function cross correlates columns but not rows so need to transcribe
colnames(Data_Corr)<-as.factor(Data_Raw[1:255,1])#pulls the feature names back to the columns of the numeric matrix.
Data_Corr_Result<-rcorr(as.matrix(Data_Corr),type = c("pearson"))#cor_mat() function should do the same thing from the rstatix package but I haven't tested it yet as an input to the igraph packages.
R_Data_Corr<-Data_Corr_Result[["r"]]
p_Data_Corr<-Data_Corr_Result[["P"]]
#write.csv(R_Data_Corr, file="Notarangelo0001 R vals pearson all v all.csv")#Option to write the R matrix to a csv. You can do the same thing for the p values for handling elsewhere if needed.
#write.csv(p_Data_Corr, file="Notarangelo0001 p vals pearson all v all.csv")
#NETWORK ANALYSIS WITH IGRAPH
R_ABS<-abs(R_Data_Corr)#convert to absolute values so that you can look at a network of high corr and anticorr
R_Sig<-R_ABS
R_Sig[R_Sig<0.6]<-0#replace anything below an R cut-off with a 0. Play with this to manage how many features make it through to the eventual network.
R_Net <- graph_from_adjacency_matrix(R_Sig, weighted=T, mode="undirected", diag=F)#This creates the network object which can be modified from here
R_Net_DF<-igraph::as_data_frame(R_Net, 'both')#split the igraph NET object into seperate edge and node(vertex) dataframes so that you can add attributes
Class_DF<-Data_Raw[1:255,1:3]#Create a Class ID dataframe. In the sample dataframe I used two attributes in columns 2 and 3 so this creates a seperate dataframe with those values.
R_Net_DF$vertices <- R_Net_DF$vertices %>%
left_join(Class_DF, by=c('name'='Metabolite'))#stitch the class ids into the vertices dataframe
#Optional. This is an attempt to add in the -Log(p) of the correlations as a edge attribute. It can be buggy and you can skip it.
Data_Corr_Flat<-cor_gather(Data_Corr_Result)#flattens the r and p results into a 4 column format that can be linked to the edge DF dataframe as attributes. Note that the data is technically duplicated with each correlation being recognized in each direction so you can't screw up the call direction below.
Data_Corr_Flat$neg_Log_p<-log10(Data_Corr_Flat$p)*-1#Adds in the -Log(p) column for assignment ot the edge weight below. This is for if you want to map the p-values from the correlations onto the map is some way. You can skip this for a simpler plot.
R_Net_DF$edges <- R_Net_DF$edges %>%
left_join(Data_Corr_Flat, by=c('from'='var1','to'='var2'))#stitch the correlation stats into the edges as attirbutes
#Rebuild the network object from the two dataframes (vertices and edges with their respective attributes)
R_Net <- graph_from_data_frame(R_Net_DF$edges,
directed = F,
vertices = R_Net_DF$vertices)#Recreate the network object from the Vertices and edges dataframes
#This is an attempt to remove edges that don't pass a certain p-value cut-off. Let me know if it doesn't work.
insig_edge<-which(edge_attr(R_Net,"neg_Log_p")<1)#this is currently set with 0.01 as the cut-off but you can toggle accordingly
R_Net_trim<- delete.edges(R_Net, insig_edge)
#These are two options that can be used to remove vertices based on degree (i.e. connectivity of a vertice). This is a great way to trim off non-informative patterns from the network. You can iterate these functions as necessary.
low_con_verts<- which(degree(R_Net_trim)<3)#identify any nodes with edges below a cut-off
R_Net_trim<- delete.vertices(R_Net_trim, low_con_verts)#remove low degree vertices. This will likely leave some loner vertices out there that get cut out in the next step.
Iso_verts<- which(degree(R_Net_trim)==0)#identify any vertices with no edges in the network
R_Net_trim<- delete.vertices(R_Net_trim, Iso_verts)#remove unconnected vertices
#Color the edges by the sign of R and assign them as edge attribute.
E(R_Net_trim)$color <- ifelse(E(R_Net_trim)$cor < 0,"purple",  "orange") # pick colors, purple = neg, orangehttp://127.0.0.1:15877/graphics/plot_zoom_png?width=2048&height=1104 = positive
#color by attribute of the vertices that was inserted into the original input file
Color_pal<-colorRampPalette((brewer.pal(3,"RdYlBu")))#expands the color palette through extrapolation for node coloring.Pick your favorite palette and dictate how many colors in that palette get blended by the number.
par(mar = rep(.1,4)) # this sets the margins to something very small so you make better use of the plotting area
#FINAL PLOT. To plot with no vertex labels just insert "vertex.label=NA" and remove the rest of the vertex.label specs
Layout.pref<-layout_with_fr(R_Net_trim)
plot(R_Net_trim,
layout=Layout.pref,
vertex.size=3,
vertex.frame.color=NA,
vertex.shape=Class_DF$Shape,
vertex.label.family="sans",
vertex.label.color="black",
vertex.label.cex=1.5,
vertex.color =  Color_pal(length(unique(Class_DF$Class)))[as.numeric(as.factor(vertex_attr(R_Net_trim, "Class")))],
edge.width=1,
edge.color=E(R_Net_trim)$color)
library(igraph)
library(dplyr)
library(Hmisc)
library(ggplot2)
library(RColorBrewer)
library(rstatix)
#CORRELATION MATRIX GENERATION. This will make an "All vs. All" matrix of correlations for your input dataset.
Data_Raw<-read.csv("Gwen_GiGi_CleanedData.csv")#Dataset should be a simple matrix with rows as features and columns as experimental conditions and/or repeats. Feature attributes (i.e. GO annots or chromosome regions) can be included as columns.You can also include columns that manully specify graph characteristics such as shape for a subset of features.
Data_Clean<-Data_Raw[1:255,4:25]#remove anything that is not a metabolite abundance//count
Data_Num<-mutate_all(Data_Clean, function(x) as.numeric(as.character(x)))#Convert all entries to numerics. Sometimes this isn't necessary but its a good check
Data_Corr<-t(Data_Num)#input to the rcorr() function cross correlates columns but not rows so need to transcribe
colnames(Data_Corr)<-as.factor(Data_Raw[1:255,1])#pulls the feature names back to the columns of the numeric matrix.
Data_Corr_Result<-rcorr(as.matrix(Data_Corr),type = c("pearson"))#cor_mat() function should do the same thing from the rstatix package but I haven't tested it yet as an input to the igraph packages.
R_Data_Corr<-Data_Corr_Result[["r"]]
p_Data_Corr<-Data_Corr_Result[["P"]]
#write.csv(R_Data_Corr, file="Notarangelo0001 R vals pearson all v all.csv")#Option to write the R matrix to a csv. You can do the same thing for the p values for handling elsewhere if needed.
#write.csv(p_Data_Corr, file="Notarangelo0001 p vals pearson all v all.csv")
#NETWORK ANALYSIS WITH IGRAPH
R_ABS<-abs(R_Data_Corr)#convert to absolute values so that you can look at a network of high corr and anticorr
R_Sig<-R_ABS
R_Sig[R_Sig<0.6]<-0#replace anything below an R cut-off with a 0. Play with this to manage how many features make it through to the eventual network.
R_Net <- graph_from_adjacency_matrix(R_Sig, weighted=T, mode="undirected", diag=F)#This creates the network object which can be modified from here
R_Net_DF<-igraph::as_data_frame(R_Net, 'both')#split the igraph NET object into seperate edge and node(vertex) dataframes so that you can add attributes
Class_DF<-Data_Raw[1:255,1:3]#Create a Class ID dataframe. In the sample dataframe I used two attributes in columns 2 and 3 so this creates a seperate dataframe with those values.
R_Net_DF$vertices <- R_Net_DF$vertices %>%
left_join(Class_DF, by=c('name'='Metabolite'))#stitch the class ids into the vertices dataframe
#Optional. This is an attempt to add in the -Log(p) of the correlations as a edge attribute. It can be buggy and you can skip it.
Data_Corr_Flat<-cor_gather(Data_Corr_Result)#flattens the r and p results into a 4 column format that can be linked to the edge DF dataframe as attributes. Note that the data is technically duplicated with each correlation being recognized in each direction so you can't screw up the call direction below.
Data_Corr_Flat$neg_Log_p<-log10(Data_Corr_Flat$p)*-1#Adds in the -Log(p) column for assignment ot the edge weight below. This is for if you want to map the p-values from the correlations onto the map is some way. You can skip this for a simpler plot.
R_Net_DF$edges <- R_Net_DF$edges %>%
left_join(Data_Corr_Flat, by=c('from'='var1','to'='var2'))#stitch the correlation stats into the edges as attirbutes
#Rebuild the network object from the two dataframes (vertices and edges with their respective attributes)
R_Net <- graph_from_data_frame(R_Net_DF$edges,
directed = F,
vertices = R_Net_DF$vertices)#Recreate the network object from the Vertices and edges dataframes
#This is an attempt to remove edges that don't pass a certain p-value cut-off. Let me know if it doesn't work.
insig_edge<-which(edge_attr(R_Net,"neg_Log_p")<1)#this is currently set with 0.01 as the cut-off but you can toggle accordingly
R_Net_trim<- delete.edges(R_Net, insig_edge)
#These are two options that can be used to remove vertices based on degree (i.e. connectivity of a vertice). This is a great way to trim off non-informative patterns from the network. You can iterate these functions as necessary.
low_con_verts<- which(degree(R_Net_trim)<3)#identify any nodes with edges below a cut-off
R_Net_trim<- delete.vertices(R_Net_trim, low_con_verts)#remove low degree vertices. This will likely leave some loner vertices out there that get cut out in the next step.
Iso_verts<- which(degree(R_Net_trim)==0)#identify any vertices with no edges in the network
R_Net_trim<- delete.vertices(R_Net_trim, Iso_verts)#remove unconnected vertices
#Color the edges by the sign of R and assign them as edge attribute.
E(R_Net_trim)$color <- ifelse(E(R_Net_trim)$cor < 0,"purple",  "orange") # pick colors, purple = neg, orangehttp://127.0.0.1:15877/graphics/plot_zoom_png?width=2048&height=1104 = positive
#color by attribute of the vertices that was inserted into the original input file
Color_pal<-colorRampPalette((brewer.pal(3,"RdYlBu")))#expands the color palette through extrapolation for node coloring.Pick your favorite palette and dictate how many colors in that palette get blended by the number.
par(mar = rep(.1,4)) # this sets the margins to something very small so you make better use of the plotting area
#FINAL PLOT. To plot with no vertex labels just insert "vertex.label=NA" and remove the rest of the vertex.label specs
Layout.pref<-layout_with_fr(R_Net_trim)
plot(R_Net_trim,
layout=Layout.pref,
vertex.size=3,
vertex.frame.color=NA,
vertex.shape=Class_DF$Shape,
vertex.label.family="sans",
vertex.label.color="black",
vertex.label.cex=1.5,
vertex.color =  Color_pal(length(unique(Class_DF$Class)))[as.numeric(as.factor(vertex_attr(R_Net_trim, "Class")))],
edge.width=1,
edge.color=E(R_Net_trim)$color)
#Optional. This is an attempt to add in the -Log(p) of the correlations as a edge attribute. It can be buggy and you can skip it.
Data_Corr_Flat<-cor_gather(Data_Corr_Result)#flattens the r and p results into a 4 column format that can be linked to the edge DF dataframe as attributes. Note that the data is technically duplicated with each correlation being recognized in each direction so you can't screw up the call direction below.
Data_Corr_Flat$neg_Log_p<-log10(Data_Corr_Flat$p)*-1#Adds in the -Log(p) column for assignment ot the edge weight below. This is for if you want to map the p-values from the correlations onto the map is some way. You can skip this for a simpler plot.
R_Net_DF$edges <- R_Net_DF$edges %>%
left_join(Data_Corr_Flat, by=c('from'='var1','to'='var2'))#stitch the correlation stats into the edges as attirbutes
#Rebuild the network object from the two dataframes (vertices and edges with their respective attributes)
R_Net <- graph_from_data_frame(R_Net_DF$edges,
directed = F,
vertices = R_Net_DF$vertices)#Recreate the network object from the Vertices and edges dataframes
#This is an attempt to remove edges that don't pass a certain p-value cut-off. Let me know if it doesn't work.
insig_edge<-which(edge_attr(R_Net,"neg_Log_p")<1)#this is currently set with 0.01 as the cut-off but you can toggle accordingly
R_Net_trim<- delete.edges(R_Net, insig_edge)
#These are two options that can be used to remove vertices based on degree (i.e. connectivity of a vertice). This is a great way to trim off non-informative patterns from the network. You can iterate these functions as necessary.
low_con_verts<- which(degree(R_Net_trim)<3)#identify any nodes with edges below a cut-off
R_Net_trim<- delete.vertices(R_Net_trim, low_con_verts)#remove low degree vertices. This will likely leave some loner vertices out there that get cut out in the next step.
Iso_verts<- which(degree(R_Net_trim)==0)#identify any vertices with no edges in the network
R_Net_trim<- delete.vertices(R_Net_trim, Iso_verts)#remove unconnected vertices
#Color the edges by the sign of R and assign them as edge attribute.
E(R_Net_trim)$color <- ifelse(E(R_Net_trim)$cor < 0,"purple",  "orange") # pick colors, purple = neg, orangehttp://127.0.0.1:15877/graphics/plot_zoom_png?width=2048&height=1104 = positive
#color by attribute of the vertices that was inserted into the original input file
Color_pal<-colorRampPalette((brewer.pal(3,"RdYlBu")))#expands the color palette through extrapolation for node coloring.Pick your favorite palette and dictate how many colors in that palette get blended by the number.
par(mar = rep(.1,4)) # this sets the margins to something very small so you make better use of the plotting area
#FINAL PLOT. To plot with no vertex labels just insert "vertex.label=NA" and remove the rest of the vertex.label specs
Layout.pref<-layout_with_fr(R_Net_trim)
plot(R_Net_trim,
layout=Layout.pref,
vertex.size=3,
vertex.frame.color=NA,
vertex.shape=Class_DF$Shape,
vertex.label.family="sans",
vertex.label.color="black",
vertex.label.cex=1.5,
vertex.color =  Color_pal(length(unique(Class_DF$Class)))[as.numeric(as.factor(vertex_attr(R_Net_trim, "Class")))],
edge.width=1,
edge.color=E(R_Net_trim)$color)
#Color the edges by the sign of R and assign them as edge attribute.
E(R_Net_trim)$color <- ifelse(E(R_Net_trim)$cor < 0,"purple",  "orange") # pick colors, purple = neg, orangehttp://127.0.0.1:15877/graphics/plot_zoom_png?width=2048&height=1104 = positive
#Optional. This is an attempt to add in the -Log(p) of the correlations as a edge attribute. It can be buggy and you can skip it.
Data_Corr_Flat<-cor_gather(Data_Corr_Result)#flattens the r and p results into a 4 column format that can be linked to the edge DF dataframe as attributes. Note that the data is technically duplicated with each correlation being recognized in each direction so you can't screw up the call direction below.
Data_Corr_Flat$neg_Log_p<-log10(Data_Corr_Flat$p)*-1#Adds in the -Log(p) column for assignment ot the edge weight below. This is for if you want to map the p-values from the correlations onto the map is some way. You can skip this for a simpler plot.
R_Net_DF$edges <- R_Net_DF$edges %>%
left_join(Data_Corr_Flat, by=c('from'='var1','to'='var2'))#stitch the correlation stats into the edges as attirbutes
#Rebuild the network object from the two dataframes (vertices and edges with their respective attributes)
R_Net <- graph_from_data_frame(R_Net_DF$edges,
directed = F,
vertices = R_Net_DF$vertices)#Recreate the network object from the Vertices and edges dataframes
#This is an attempt to remove edges that don't pass a certain p-value cut-off. Let me know if it doesn't work.
insig_edge<-which(edge_attr(R_Net,"neg_Log_p")<1)#this is currently set with 0.01 as the cut-off but you can toggle accordingly
R_Net_trim<- delete.edges(R_Net, insig_edge)
#These are two options that can be used to remove vertices based on degree (i.e. connectivity of a vertice). This is a great way to trim off non-informative patterns from the network. You can iterate these functions as necessary.
low_con_verts<- which(degree(R_Net_trim)<3)#identify any nodes with edges below a cut-off
R_Net_trim<- delete.vertices(R_Net_trim, low_con_verts)#remove low degree vertices. This will likely leave some loner vertices out there that get cut out in the next step.
Iso_verts<- which(degree(R_Net_trim)==0)#identify any vertices with no edges in the network
R_Net_trim<- delete.vertices(R_Net_trim, Iso_verts)#remove unconnected vertices
#Color the edges by the sign of R and assign them as edge attribute.
E(R_Net_trim)$color <- ifelse(E(R_Net_trim)$cor < 0,"purple",  "orange") # pick colors, purple = neg, orangehttp://127.0.0.1:15877/graphics/plot_zoom_png?width=2048&height=1104 = positive
#color by attribute of the vertices that was inserted into the original input file
Color_pal<-colorRampPalette((brewer.pal(3,"RdYlBu")))#expands the color palette through extrapolation for node coloring.Pick your favorite palette and dictate how many colors in that palette get blended by the number.
par(mar = rep(.1,4)) # this sets the margins to something very small so you make better use of the plotting area
#FINAL PLOT. To plot with no vertex labels just insert "vertex.label=NA" and remove the rest of the vertex.label specs
Layout.pref<-layout_with_fr(R_Net_trim)
plot(R_Net_trim,
layout=Layout.pref,
vertex.size=3,
vertex.frame.color=NA,
vertex.shape=Class_DF$Shape,
vertex.label.family="sans",
vertex.label.color="black",
vertex.label.cex=1.5,
vertex.color =  Color_pal(length(unique(Class_DF$Class)))[as.numeric(as.factor(vertex_attr(R_Net_trim, "Class")))],
edge.width=1,
edge.color=E(R_Net_trim)$color)
#Optional. This is an attempt to add in the -Log(p) of the correlations as a edge attribute. It can be buggy and you can skip it.
Data_Corr_Flat<-cor_gather(Data_Corr_Result)#flattens the r and p results into a 4 column format that can be linked to the edge DF dataframe as attributes. Note that the data is technically duplicated with each correlation being recognized in each direction so you can't screw up the call direction below.
Data_Corr_Flat$neg_Log_p<-log10(Data_Corr_Flat$p)*-1#Adds in the -Log(p) column for assignment ot the edge weight below. This is for if you want to map the p-values from the correlations onto the map is some way. You can skip this for a simpler plot.
R_Net_DF$edges <- R_Net_DF$edges %>%
left_join(Data_Corr_Flat, by=c('from'='var1','to'='var2'))#stitch the correlation stats into the edges as attirbutes
#Rebuild the network object from the two dataframes (vertices and edges with their respective attributes)
R_Net <- graph_from_data_frame(R_Net_DF$edges,
directed = F,
vertices = R_Net_DF$vertices)#Recreate the network object from the Vertices and edges dataframes
#This is an attempt to remove edges that don't pass a certain p-value cut-off. Let me know if it doesn't work.
insig_edge<-which(edge_attr(R_Net,"neg_Log_p")<1)#this is currently set with 0.01 as the cut-off but you can toggle accordingly
R_Net_trim<- delete.edges(R_Net, insig_edge)
#These are two options that can be used to remove vertices based on degree (i.e. connectivity of a vertice). This is a great way to trim off non-informative patterns from the network. You can iterate these functions as necessary.
low_con_verts<- which(degree(R_Net_trim)<3)#identify any nodes with edges below a cut-off
R_Net_trim<- delete.vertices(R_Net_trim, low_con_verts)#remove low degree vertices. This will likely leave some loner vertices out there that get cut out in the next step.
Iso_verts<- which(degree(R_Net_trim)==0)#identify any vertices with no edges in the network
R_Net_trim<- delete.vertices(R_Net_trim, Iso_verts)#remove unconnected vertices
#Color the edges by the sign of R and assign them as edge attribute.
E(R_Net_trim)$color <- ifelse(E(R_Net_trim)$cor < 0,"purple",  "orange") # pick colors, purple = neg, orangehttp://127.0.0.1:15877/graphics/plot_zoom_png?width=2048&height=1104 = positive
library(igraph)
library(dplyr)
library(Hmisc)
library(ggplot2)
library(RColorBrewer)
library(rstatix)
#CORRELATION MATRIX GENERATION. This will make an "All vs. All" matrix of correlations for your input dataset.
Data_Raw<-read.csv("Gwen_GiGi_CleanedData.csv")#Dataset should be a simple matrix with rows as features and columns as experimental conditions and/or repeats. Feature attributes (i.e. GO annots or chromosome regions) can be included as columns.You can also include columns that manully specify graph characteristics such as shape for a subset of features.
Data_Clean<-Data_Raw[1:255,4:25]#remove anything that is not a metabolite abundance//count
Data_Num<-mutate_all(Data_Clean, function(x) as.numeric(as.character(x)))#Convert all entries to numerics. Sometimes this isn't necessary but its a good check
Data_Corr<-t(Data_Num)#input to the rcorr() function cross correlates columns but not rows so need to transcribe
colnames(Data_Corr)<-as.factor(Data_Raw[1:255,1])#pulls the feature names back to the columns of the numeric matrix.
Data_Corr_Result<-rcorr(as.matrix(Data_Corr),type = c("pearson"))#cor_mat() function should do the same thing from the rstatix package but I haven't tested it yet as an input to the igraph packages.
R_Data_Corr<-Data_Corr_Result[["r"]]
p_Data_Corr<-Data_Corr_Result[["P"]]
#write.csv(R_Data_Corr, file="Notarangelo0001 R vals pearson all v all.csv")#Option to write the R matrix to a csv. You can do the same thing for the p values for handling elsewhere if needed.
#write.csv(p_Data_Corr, file="Notarangelo0001 p vals pearson all v all.csv")
#NETWORK ANALYSIS WITH IGRAPH
R_ABS<-abs(R_Data_Corr)#convert to absolute values so that you can look at a network of high corr and anticorr
R_Sig<-R_ABS
R_Sig[R_Sig<0.6]<-0#replace anything below an R cut-off with a 0. Play with this to manage how many features make it through to the eventual network.
R_Net <- graph_from_adjacency_matrix(R_Sig, weighted=T, mode="undirected", diag=F)#This creates the network object which can be modified from here
R_Net_DF<-igraph::as_data_frame(R_Net, 'both')#split the igraph NET object into seperate edge and node(vertex) dataframes so that you can add attributes
Class_DF<-Data_Raw[1:255,1:3]#Create a Class ID dataframe. In the sample dataframe I used two attributes in columns 2 and 3 so this creates a seperate dataframe with those values.
R_Net_DF$vertices <- R_Net_DF$vertices %>%
left_join(Class_DF, by=c('name'='Metabolite'))#stitch the class ids into the vertices dataframe
#Optional. This is an attempt to add in the -Log(p) of the correlations as a edge attribute. It can be buggy and you can skip it.
Data_Corr_Flat<-cor_gather(Data_Corr_Result)#flattens the r and p results into a 4 column format that can be linked to the edge DF dataframe as attributes. Note that the data is technically duplicated with each correlation being recognized in each direction so you can't screw up the call direction below.
Data_Corr_Flat$neg_Log_p<-log10(Data_Corr_Flat$p)*-1#Adds in the -Log(p) column for assignment ot the edge weight below. This is for if you want to map the p-values from the correlations onto the map is some way. You can skip this for a simpler plot.
R_Net_DF$edges <- R_Net_DF$edges %>%
left_join(Data_Corr_Flat, by=c('from'='var1','to'='var2'))#stitch the correlation stats into the edges as attirbutes
#Rebuild the network object from the two dataframes (vertices and edges with their respective attributes)
R_Net <- graph_from_data_frame(R_Net_DF$edges,
directed = F,
vertices = R_Net_DF$vertices)#Recreate the network object from the Vertices and edges dataframes
#This is an attempt to remove edges that don't pass a certain p-value cut-off. Let me know if it doesn't work.
insig_edge<-which(edge_attr(R_Net,"neg_Log_p")<1)#this is currently set with 0.01 as the cut-off but you can toggle accordingly
R_Net_trim<- delete.edges(R_Net, insig_edge)
#These are two options that can be used to remove vertices based on degree (i.e. connectivity of a vertice). This is a great way to trim off non-informative patterns from the network. You can iterate these functions as necessary.
low_con_verts<- which(degree(R_Net_trim)<3)#identify any nodes with edges below a cut-off
R_Net_trim<- delete.vertices(R_Net_trim, low_con_verts)#remove low degree vertices. This will likely leave some loner vertices out there that get cut out in the next step.
Iso_verts<- which(degree(R_Net_trim)==0)#identify any vertices with no edges in the network
R_Net_trim<- delete.vertices(R_Net_trim, Iso_verts)#remove unconnected vertices
#Color the edges by the sign of R and assign them as edge attribute.
E(R_Net_trim)$color <- ifelse(E(R_Net_trim)$cor < 0,"purple",  "orange") # pick colors, purple = neg, orangehttp://127.0.0.1:15877/graphics/plot_zoom_png?width=2048&height=1104 = positive
#I think this is bugging out because of lines 37-41 which are the optional lines that are adding the neg log og p - which is why the pos/neg isnt working since you took the negative log of P
#color by attribute of the vertices that was inserted into the original input file
Color_pal<-colorRampPalette((brewer.pal(3,"RdYlBu")))#expands the color palette through extrapolation for node coloring.Pick your favorite palette and dictate how many colors in that palette get blended by the number.
par(mar = rep(.1,4)) # this sets the margins to something very small so you make better use of the plotting area
#FINAL PLOT. To plot with no vertex labels just insert "vertex.label=NA" and remove the rest of the vertex.label specs
Layout.pref<-layout_with_fr(R_Net_trim)
plot(R_Net_trim,
layout=Layout.pref,
vertex.size=3,
vertex.frame.color=NA,
vertex.shape=Class_DF$Shape,
vertex.label.family="sans",
vertex.label.color="black",
vertex.label.cex=1.5,
vertex.color =  Color_pal(length(unique(Class_DF$Class)))[as.numeric(as.factor(vertex_attr(R_Net_trim, "Class")))],
edge.width=1,
edge.color=E(R_Net_trim)$color)
Optional. This is an attempt to add in the -Log(p) of the correlations as a edge attribute. It can be buggy and you can skip it.
#Optional. This is an attempt to add in the -Log(p) of the correlations as a edge attribute. It can be buggy and you can skip it.
Data_Corr_Flat<-cor_gather(Data_Corr_Result)#flattens the r and p results into a 4 column format that can be linked to the edge DF dataframe as attributes. Note that the data is technically duplicated with each correlation being recognized in each direction so you can't screw up the call direction below.
Data_Corr_Flat$neg_Log_p<-log10(Data_Corr_Flat$p)*-1#Adds in the -Log(p) column for assignment ot the edge weight below. This is for if you want to map the p-values from the correlations onto the map is some way. You can skip this for a simpler plot.
R_Net_DF$edges <- R_Net_DF$edges %>%
left_join(Data_Corr_Flat, by=c('from'='var1','to'='var2'))#stitch the correlation stats into the edges as attirbutes
#Rebuild the network object from the two dataframes (vertices and edges with their respective attributes)
R_Net <- graph_from_data_frame(R_Net_DF$edges,
directed = F,
vertices = R_Net_DF$vertices)#Recreate the network object from the Vertices and edges dataframes
View(R_Net_DF)
View(Data_Clean)
View(Data_Raw)
dat_scaled <- Data_Raw %>%
tidyr::pivot_longer(cols = 4:ncol(Data_Raw), names_to = "Sample", values_to = "Value_raw") %>%
group_by(Metabolite) %>%
mutate(Value_scaled = as.numeric(scale(Value_raw, center=TRUE, scale=TRUE))) %>%
ungroup() %>%
select(-Value_raw) %>%
tidyr::pivot_wider(id_cols = 1:3, names_from = Sample, values_from = Value_scaled)
View(dat_scaled)
Data_Clean<-Data_Raw[1:255,4:25]#remove anything that is not a metabolite abundance//count
Data_Num<-mutate_all(Data_Clean, function(x) as.numeric(as.character(x)))#Convert all entries to numerics. Sometimes this isn't necessary but its a good check
Data_Corr<-t(Data_Num)#input to the rcorr() function cross correlates columns but not rows so need to transcribe
colnames(Data_Corr)<-as.factor(Data_Raw[1:255,1])#pulls the feature names back to the columns of the numeric matrix.
Data_Corr_Result<-rcorr(as.matrix(Data_Corr),type = c("pearson"))#cor_mat() function should do the same thing from the rstatix package but I haven't tested it yet as an input to the igraph packages.
R_Data_Corr<-Data_Corr_Result[["r"]]
p_Data_Corr<-Data_Corr_Result[["P"]]
#write.csv(R_Data_Corr, file="Notarangelo0001 R vals pearson all v all.csv")#Option to write the R matrix to a csv. You can do the same thing for the p values for handling elsewhere if needed.
#write.csv(p_Data_Corr, file="Notarangelo0001 p vals pearson all v all.csv")
#NETWORK ANALYSIS WITH IGRAPH
R_ABS<-abs(R_Data_Corr)#convert to absolute values so that you can look at a network of high corr and anticorr
R_Sig<-R_ABS
R_Sig[R_Sig<0.6]<-0#replace anything below an R cut-off with a 0. Play with this to manage how many features make it through to the eventual network.
R_Net <- graph_from_adjacency_matrix(R_Sig, weighted=T, mode="undirected", diag=F)#This creates the network object which can be modified from here
R_Net_DF<-igraph::as_data_frame(R_Net, 'both')#split the igraph NET object into seperate edge and node(vertex) dataframes so that you can add attributes
Class_DF<-Data_Raw[1:255,1:3]#Create a Class ID dataframe. In the sample dataframe I used two attributes in columns 2 and 3 so this creates a seperate dataframe with those values.
R_Net_DF$vertices <- R_Net_DF$vertices %>%
left_join(Class_DF, by=c('name'='Metabolite'))#stitch the class ids into the vertices dataframe
#Optional. This is an attempt to add in the -Log(p) of the correlations as a edge attribute. It can be buggy and you can skip it.
Data_Corr_Flat<-cor_gather(Data_Corr_Result)#flattens the r and p results into a 4 column format that can be linked to the edge DF dataframe as attributes. Note that the data is technically duplicated with each correlation being recognized in each direction so you can't screw up the call direction below.
Data_Corr_Flat$neg_Log_p<-log10(Data_Corr_Flat$p)*-1#Adds in the -Log(p) column for assignment ot the edge weight below. This is for if you want to map the p-values from the correlations onto the map is some way. You can skip this for a simpler plot.
R_Net_DF$edges <- R_Net_DF$edges %>%
left_join(Data_Corr_Flat, by=c('from'='var1','to'='var2'))#stitch the correlation stats into the edges as attirbutes
#Rebuild the network object from the two dataframes (vertices and edges with their respective attributes)
R_Net <- graph_from_data_frame(R_Net_DF$edges,
directed = F,
vertices = R_Net_DF$vertices)#Recreate the network object from the Vertices and edges dataframes
#This is an attempt to remove edges that don't pass a certain p-value cut-off. Let me know if it doesn't work.
insig_edge<-which(edge_attr(R_Net,"neg_Log_p")<1)#this is currently set with 0.01 as the cut-off but you can toggle accordingly
R_Net_trim<- delete.edges(R_Net, insig_edge)
#These are two options that can be used to remove vertices based on degree (i.e. connectivity of a vertice). This is a great way to trim off non-informative patterns from the network. You can iterate these functions as necessary.
low_con_verts<- which(degree(R_Net_trim)<3)#identify any nodes with edges below a cut-off
R_Net_trim<- delete.vertices(R_Net_trim, low_con_verts)#remove low degree vertices. This will likely leave some loner vertices out there that get cut out in the next step.
Iso_verts<- which(degree(R_Net_trim)==0)#identify any vertices with no edges in the network
R_Net_trim<- delete.vertices(R_Net_trim, Iso_verts)#remove unconnected vertices
#Color the edges by the sign of R and assign them as edge attribute.
E(R_Net_trim)$color <- ifelse(E(R_Net_trim)$cor < 0,"purple",  "orange") # pick colors, purple = neg, orangehttp://127.0.0.1:15877/graphics/plot_zoom_png?width=2048&height=1104 = positive
#I think this is bugging out because of lines 37-41 which are the optional lines that are adding the neg log og p - which is why the pos/neg isnt working since you took the negative log of P
#color by attribute of the vertices that was inserted into the original input file
Color_pal<-colorRampPalette((brewer.pal(3,"RdYlBu")))#expands the color palette through extrapolation for node coloring.Pick your favorite palette and dictate how many colors in that palette get blended by the number.
par(mar = rep(.1,4)) # this sets the margins to something very small so you make better use of the plotting area
#FINAL PLOT. To plot with no vertex labels just insert "vertex.label=NA" and remove the rest of the vertex.label specs
Layout.pref<-layout_with_fr(R_Net_trim)
plot(R_Net_trim,
layout=Layout.pref,
vertex.size=3,
vertex.frame.color=NA,
vertex.shape=Class_DF$Shape,
vertex.label.family="sans",
vertex.label.color="black",
vertex.label.cex=1.5,
vertex.color =  Color_pal(length(unique(Class_DF$Class)))[as.numeric(as.factor(vertex_attr(R_Net_trim, "Class")))],
edge.width=1,
edge.color=E(R_Net_trim)$color)
library(igraph)
library(dplyr)
library(Hmisc)
library(ggplot2)
library(RColorBrewer)
library(rstatix)
#CORRELATION MATRIX GENERATION. This will make an "All vs. All" matrix of correlations for your input dataset.
Data_Raw<-read.csv("Gwen_GiGi_CleanedData.csv")#Dataset should be a simple matrix with rows as features and columns as experimental conditions and/or repeats. Feature attributes (i.e. GO annots or chromosome regions) can be included as columns.You can also include columns that manully specify graph characteristics such as shape for a subset of features.
dat_scaled <- Data_Raw %>%
tidyr::pivot_longer(cols = 4:ncol(Data_Raw), names_to = "Sample", values_to = "Value_raw") %>%
group_by(Metabolite) %>%
mutate(Value_scaled = as.numeric(scale(Value_raw, center=TRUE, scale=TRUE))) %>%
ungroup() %>%
select(-Value_raw) %>%
tidyr::pivot_wider(id_cols = 1:3, names_from = Sample, values_from = Value_scaled)
Data_Clean<-Data_Raw[1:255,4:25]#remove anything that is not a metabolite abundance//count
Data_Num<-mutate_all(Data_Clean, function(x) as.numeric(as.character(x)))#Convert all entries to numerics. Sometimes this isn't necessary but its a good check
Data_Corr<-t(Data_Num)#input to the rcorr() function cross correlates columns but not rows so need to transcribe
colnames(Data_Corr)<-as.factor(Data_Raw[1:255,1])#pulls the feature names back to the columns of the numeric matrix.
Data_Corr_Result<-rcorr(as.matrix(Data_Corr),type = c("pearson"))#cor_mat() function should do the same thing from the rstatix package but I haven't tested it yet as an input to the igraph packages.
R_Data_Corr<-Data_Corr_Result[["r"]]
p_Data_Corr<-Data_Corr_Result[["P"]]
#NETWORK ANALYSIS WITH IGRAPH
R_ABS<-abs(R_Data_Corr)#convert to absolute values so that you can look at a network of high corr and anticorr
R_Sig<-R_ABS
# Generate example data
df <- data.frame(
RT = runif(1000, min = 0.026, max = 13.9),
mz = rnorm(1000, mean = 200, sd = 50) + rnorm(1000, mean = 0, sd = 10) * runif(1000, min = 0.5, max = 1.5)
)
# Apply categorization function with adjusted window overlap
df_categorized <- categorize_by_rt_window(df, overlap = 0.5)
# Generate example data
df <- data.frame(
RT = runif(1000, min = 0.026, max = 13.9),
mz = rnorm(1000, mean = 200, sd = 50) + rnorm(1000, mean = 0, sd = 10) * runif(1000, min = 0.5, max = 1.5)
)
install_github("IDSS-NIAID/MetLipNet")
devtools::install_github("IDSS-NIAID/MetLipNet")
devtools::install_github("IDSS-NIAID/MetLipNet")
#### Required Libraries ####
library(MetLipNet)
library(igraph)
library(ggraph)
library(openxlsx)
library(dplyr)
library(future)
library(furrr)
library(RColorBrewer)
# Generate example data
df <- data.frame(
RT = runif(1000, min = 0.026, max = 13.9),
mz = rnorm(1000, mean = 200, sd = 50) + rnorm(1000, mean = 0, sd = 10) * runif(1000, min = 0.5, max = 1.5)
)
# Apply categorization function with adjusted window overlap
df_categorized <- categorize_by_rt_window(df, overlap = 0.5)
# Display first 3 rows per RT window
df_categorized %>%
group_by(Window) %>%
slice_head(n = 3) %>%
print()
# Apply function to calculate m/z differences and match to pre-determined chemical groups
df_mz_differences_filtered <- calculate_mz_differences(df_categorized, selected_groups = c("17", "14", "28"))
head(df_mz_differences_filtered)
devtools::check("MetLipNet")
# Simulate example data
df <- data.frame(
RT = runif(1000, min = 0.026, max = 13.9),
mz = rnorm(1000, mean = 200, sd = 50) + rnorm(1000, mean = 0, sd = 10) * runif(1000, min = 0.5, max = 1.5)
)
# Apply categorization function with adjusted window overlap
df_categorized <- categorize_by_rt_window(df, overlap = 0.5)
# Display first 3 rows per RT window
df_categorized %>%
group_by(Window) %>%
slice_head(n = 3) %>%
print()
# Apply function to calculate m/z differences and match to pre-determined chemical groups
df_mz_differences_filtered <- calculate_mz_differences(df_categorized, selected_groups = c("17", "14", "28"))
head(df_mz_differences_filtered)
# Simulate example data
df <- data.frame(
RT = runif(1000, min = 0.026, max = 13.9),
mz = rnorm(1000, mean = 200, sd = 50) + rnorm(1000, mean = 0, sd = 10) * runif(1000, min = 0.5, max = 1.5)
)
# Apply categorization function with adjusted window overlap
df_categorized <- categorize_by_rt_window(df, overlap = 0.5)
# Display first 3 rows per RT window
df_categorized %>%
group_by(Window) %>%
slice_head(n = 3) %>%
print()
# Apply function to calculate m/z differences and match to pre-determined chemical groups
df_mz_differences_filtered <- calculate_mz_differences(df_categorized, selected_groups = c("17", "14", "28"))
# Display first few rows
head(df_mz_differences_filtered)
# Apply function to optimize layout and save network images
net_viz(df_mz_differences_filtered, image_format = ".svg")
#### Install Our MetLip Custom Package ####
devtools::install_github("IDSS-NIAID/MetLipNet")
#### Open Required Libraries ####
library(MetLipNet)
library(igraph)
library(ggraph)
library(openxlsx)
library(dplyr)
library(future)
library(furrr)
library(RColorBrewer)
# Apply function to optimize layout and save network images
net_viz(df_mz_differences_filtered, image_format = ".svg")
setwd("~/GitHub/Untargeted-Metabolomics-Network-Analysis")
roxygen2::roxygenise()
pkgload::dev_help('optimize_network_layout')
#### Install Our MetLip Custom Package ####
devtools::install_github("IDSS-NIAID/MetLipNet")
#### Install Our MetLip Custom Package ####
devtools::install_github("IDSS-NIAID/MetLipNet")
